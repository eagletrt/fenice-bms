
.. _program_listing_file_mainboard_Src_peripherals_ltc6813.c:

Program Listing for File ltc6813.c
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_mainboard_Src_peripherals_ltc6813.c>` (``mainboard/Src/peripherals/ltc6813.c``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #include "peripherals/ltc6813.h"
   
   #include "main.h"
   
   uint8_t GPIO_CONFIG;
   
   void ltc6813_enable_cs(SPI_HandleTypeDef *spi, GPIO_TypeDef *gpio,
                          uint16_t pin) {
       HAL_GPIO_WritePin(gpio, pin, GPIO_PIN_RESET);
       while (spi->State != HAL_SPI_STATE_READY)
           ;
   }
   
   void ltc6813_disable_cs(SPI_HandleTypeDef *spi, GPIO_TypeDef *gpio,
                           uint16_t pin) {
       while (spi->State != HAL_SPI_STATE_READY)
           ;
       HAL_GPIO_WritePin(gpio, pin, GPIO_PIN_SET);
   }
   
   void _ltc6813_adcv(SPI_HandleTypeDef *spi, bool dcp) {
       uint8_t cmd[4];
       uint16_t cmd_pec;
       cmd[0] = (uint8_t)0b00000011;
       cmd[1] = (uint8_t)0b01100000 + dcp * 0b00010000;
       cmd_pec = ltc6813_pec15(2, cmd);
       cmd[2] = (uint8_t)(cmd_pec >> 8);
       cmd[3] = (uint8_t)(cmd_pec);
   
       ltc6813_enable_cs(spi, CS_LTC_GPIO_Port, CS_LTC_Pin);
       ltc6813_wakeup_idle(spi);
   
       HAL_SPI_Transmit(spi, cmd, 4, 100);
   
       ltc6813_disable_cs(spi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   }
   
   void _ltc6813_wrcfg(SPI_HandleTypeDef *hspi, bool start_bal, bool even) {
       // TODO: remove this function
       uint8_t wrcfg[4];
       uint8_t cfgr[8];
   
       uint16_t cmd_pec;
   
       wrcfg[0] = 0x00;
       wrcfg[1] = 0x01;
       cmd_pec = ltc6813_pec15(2, wrcfg);
       wrcfg[2] = (uint8_t)(cmd_pec >> 8);
       wrcfg[3] = (uint8_t)(cmd_pec);
   
       cfgr[0] = 0x00;
       cfgr[1] = 0x00;
       cfgr[2] = 0x00;
       cfgr[3] = 0x00;
   
       if (start_bal) {
           if (even) {
               // Command to balance cells (in order) 8,5,3,1 and 10
               cfgr[4] = 0b10010101;
               cfgr[5] = 0b00000010;
           } else {
               // Command to balance cells (in order) 7,4,2 and 9
               cfgr[4] = 0b01001010;
               // First 4 bits are for DCT0 and should remain 0
               cfgr[5] = 0b00000001;
           }
       } else {
           cfgr[4] = 0x00;
           cfgr[5] = 0x00;
       }
       cmd_pec = ltc6813_pec15(6, cfgr);
       cfgr[6] = (uint8_t)(cmd_pec >> 8);
       cfgr[7] = (uint8_t)(cmd_pec);
   
       ltc6813_wakeup_idle(hspi);
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
       HAL_SPI_Transmit(hspi, wrcfg, 4, 100);
       HAL_SPI_Transmit(hspi, cfgr, 8, 100);
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   
       // TODO: remove this
       _ltc6813_adcv(hspi, start_bal);
   }
   
   void ltc6813_wrcfg(SPI_HandleTypeDef *hspi, bool is_a,
                      uint8_t cfgr[LTC6813_COUNT][8]) {
       uint8_t cmd[4] = {0};
   
       if (is_a) {
           // WRCFGA
           cmd[1] = 1;
       } else {
           // WRCFGB
           cmd[1] = 0b00100100;
       }
   
       uint16_t cmd_pec = ltc6813_pec15(2, cmd);
       cmd[2] = (uint8_t)(cmd_pec >> 8);
       cmd[3] = (uint8_t)(cmd_pec);
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
       HAL_SPI_Transmit(hspi, cmd, 4, 100);
   
       for (uint8_t i = 0; i < LTC6813_COUNT; i++) {
           // set the configuration for the #i ltc on the chain
           // GPIO configs are equal for all ltcs
           cfgr[i][GPIO_CFGAR_POS] =
               GPIO_CONFIG + ((!GPIO_CFGAR_MASK) | cfgr[i][GPIO_CFGAR_POS]);
           HAL_SPI_Transmit(hspi, cfgr[i], 8, 100);
       }
   
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   }
   
   void ltc6813_wrcomm_i2c(SPI_HandleTypeDef *hspi, uint8_t data[8]) {
       uint8_t cmd[4] = {0b00000111, 0b00100001};  // WRCOMM
       uint16_t cmd_pec = ltc6813_pec15(2, cmd);
       cmd[2] = (uint8_t)(cmd_pec >> 8);
       cmd[3] = (uint8_t)(cmd_pec);
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
       HAL_SPI_Transmit(hspi, cmd, 4, 100);
       HAL_SPI_Transmit(hspi, data, 8, 100);
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   }
   
   bool ltc6813_rdcomm_i2c(SPI_HandleTypeDef *hspi, uint8_t data[8]) {
       uint8_t cmd[4] = {0b00000111, 0b00100010};  // RDCOMM
   
       uint16_t cmd_pec = ltc6813_pec15(2, cmd);
       cmd[2] = (uint8_t)(cmd_pec >> 8);
       cmd[3] = (uint8_t)(cmd_pec);
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
       HAL_SPI_Transmit(hspi, cmd, 4, 100);
       HAL_SPI_Receive(hspi, data, 8, 100);
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   
       if (ltc6813_pec15(6, data) == (uint16_t)(data[6] * 256 + data[7])) {
           return true;
       }
       return false;
   }
   
   void ltc6813_stcomm_i2c(SPI_HandleTypeDef *hspi, uint8_t length) {
       uint8_t cmd[4] = {0b00000111, 0b00100011};  // STCOMM
   
       uint16_t cmd_pec = ltc6813_pec15(2, cmd);
       cmd[2] = (uint8_t)(cmd_pec >> 8);
       cmd[3] = (uint8_t)(cmd_pec);
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   
       HAL_SPI_Transmit(hspi, cmd, 4, 100);
       for (uint8_t i = 0; i < 3 * length; i++) {
           HAL_SPI_Transmit(hspi, (uint8_t *)0xFF, 1, 20);
       }
   
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   }
   
   void ltc6813_wakeup_idle(SPI_HandleTypeDef *hspi) {
       uint8_t data = 0xFF;
   
       ltc6813_enable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   
       HAL_SPI_Transmit(hspi, &data, 1, 1);
   
       ltc6813_disable_cs(hspi, CS_LTC_GPIO_Port, CS_LTC_Pin);
   }
   
   uint16_t ltc6813_pec15(uint8_t len, uint8_t data[]) {
       uint16_t remainder, address;
       remainder = 16;  // PEC seed
       for (int i = 0; i < len; i++) {
           // calculate PEC table address
           address = ((remainder >> 7) ^ data[i]) & 0xff;
           remainder = (remainder << 8) ^ crcTable[address];
       }
       // The CRC15 has a 0 in the LSB so the final value must be multiplied by 2
       return (remainder * 2);
   }
