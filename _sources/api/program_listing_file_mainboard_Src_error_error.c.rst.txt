
.. _program_listing_file_mainboard_Src_error_error.c:

Program Listing for File error.c
================================

|exhale_lsh| :ref:`Return to documentation for file <file_mainboard_Src_error_error.c>` (``mainboard/Src/error/error.c``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #include "error/error.h"
   
   #include <stdlib.h>
   
   #include "error/error_list_ref.h"
   #include "tim.h"
   
   const error_timeout error_timeouts[ERROR_NUM_ERRORS] = {
       [ERROR_LTC_PEC_ERROR] = SOFT,
       [ERROR_CELL_UNDER_VOLTAGE] = SHORT,
       [ERROR_CELL_OVER_VOLTAGE] = SHORT,
       [ERROR_CELL_OVER_TEMPERATURE] = REGULAR,
       [ERROR_OVER_CURRENT] = SHORT,
       [ERROR_CAN] = REGULAR,
       [ERROR_ADC_INIT] = SOFT,
       [ERROR_ADC_TIMEOUT] = SOFT,
       [ERROR_INT_VOLTAGE_MISMATCH] = SOFT,
       [ERROR_FEEDBACK_HARD] = INSTANT,
       [ERROR_FEEDBACK_SOFT] = SOFT};
   
   llist er_list = NULL;
   
   uint32_t get_timeout_delta(error_t *error) {
       uint32_t delta = error->timestamp + error_timeouts[error->id] - HAL_GetTick();
       return delta >= 0 ? delta : 0;
   }
   
   bool error_equals(llist_node a, llist_node b) {
       return ((error_t *)a)->id == ((error_t *)b)->id && ((error_t *)a)->offset == ((error_t *)b)->offset;
   }
   
   int8_t error_compare(llist_node a, llist_node b) {
       if (get_timeout_delta((error_t *)a) < get_timeout_delta((error_t *)b))
           return 1;
       if (get_timeout_delta((error_t *)a) == get_timeout_delta((error_t *)b))
           return 0;
       return -1;
   }
   
   bool error_set_timer(error_t *error) {
       HAL_TIM_Base_Stop_IT(&htim_Err);
   
       if (error != NULL && error->state == ERROR_ACTIVE) {
           // Set counter period register to the delta
           htim_Err.Instance->ARR = get_timeout_delta(error) - 1;
           HAL_TIM_Base_Start_IT(&htim_Err);
   
           return true;
       }
   
       return false;
   }
   
   void error_init() {
       er_list = llist_init(error_compare, error_equals);
   }
   
   void error_init_error(error_t *error, error_id id, uint8_t offset, uint32_t timestamp) {
       error->id = id;
       error->offset = offset;
       error->state = ERROR_ACTIVE;
       error->timestamp = timestamp;
   }
   
   bool error_set(error_id id, uint8_t offset, uint32_t timestamp) {
       // Check if error exists
       if (*error_list_ref_array_element(id, offset) == NULL) {
           error_t *error = malloc(sizeof(error_t));
   
           if (error == NULL) {
               return false;
           }
   
           error_init_error(error, id, offset, timestamp);
   
           if (llist_insert_priority(er_list, (llist_node)error) != LLIST_SUCCESS) {
               return false;
           }
   
           //ERROR_GET_REF(id, offset) = (llist_node)error;
           (*error_list_ref_array_element(id, offset)) = (llist_node)error;
           //error_list_ref_array[id][offset] = (llist_node)error;
           // Re-set timer if first in list
           if (error_equals(llist_get_head(er_list), error)) {
               error_set_timer(error);
           }
       }
   
       return true;
   }
   
   bool error_unset(error_id id, uint8_t offset) {
       if (*error_list_ref_array_element(id, offset) != NULL) {
           error_t *error = (error_t *)(*error_list_ref_array_element(id, offset));
   
           // Check if error is fatal; in that case do not remove it, but deactivate it
           if (error->state == ERROR_FATAL) {
               //error->state = ERROR_NOT_ACTIVE;
               return true;
           }
   
           // If we are removing the first error, re-set the timer to the second error
           if (error_equals(llist_get_head(er_list), (llist_node)error)) {
               error_t *tmp = NULL;
   
               // No need to check llist_get output because passing NULL to error_set_timer is legal
               llist_get(er_list, 1, (llist_node *)&tmp);
               error_set_timer(tmp);
           }
   
           if (llist_remove_by_node(er_list, (llist_node)error) != LLIST_SUCCESS) {
               return false;
           }
   
           //ERROR_GET_REF(id, offset) = NULL;
           (*error_list_ref_array_element(id, offset)) = NULL;
           //error_list_ref_array[id][offset] = NULL;
           return true;
       }
   
       return false;
   }
   
   // TODO: Remove
   uint8_t error_count() {
       return llist_size(er_list);
   }
   
   void error_dump(error_t errors[]) {
       llist_export(er_list, (void *)errors, sizeof(error_t));
   }
